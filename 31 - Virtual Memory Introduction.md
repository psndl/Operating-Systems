

---

### 1. Operating System as a Resource Manager (Recap)

- **Processes** request CPU time, memory, I/O, and files.
    
- The OS allocates and de‑allocates these resources to ensure fairness, efficiency, protection, and isolation.
    
- **Memory** is one of the most critical resources: too little and programs can’t run; too much and we waste hardware.
    

---

### 2. Motivation for Virtual Memory

- **Illusion of a large, contiguous address space**
    
    - Each process sees its own private “memory” starting at address 0, regardless of physical RAM size.
        
- **Multiprogramming**
    
    - More processes can be kept “in memory” than physical RAM allows by swapping parts in and out.
        
- **Protection and Isolation**
    
    - Memory references outside a process’s assigned space can be caught (segmentation faults).
        
- **Simplified Programming Model**
    
    - Programmers needn’t manage physical memory placement or deal with fragmentation manually.
        

---

### 3. Logical vs. Physical Addresses

- **Logical (Virtual) Address**: the address generated by the CPU.
    
- **Physical Address**: the address seen by the memory unit.
    
- **Address Translation** performed by the Memory Management Unit (MMU).
    

---

### 4. Paging

1. **Divide** both physical memory and logical address space into fixed‑size blocks:
    
    - **Page** = block in logical memory (e.g., 4 KiB)
        
    - **Frame** = block in physical memory
        
2. **Page Table**
    
    - One entry per page: maps Virtual Page Number → Frame Number + status bits (present/absent, dirty, reference).
        
3. **Translation Steps**
    
    1. CPU issues logical address (VPN, offset).
        
    2. MMU looks up VPN in page table → gets PFN.
        
    3. Physical address = (PFN × page size) + offset.
        

---

### 5. Translation Lookaside Buffer (TLB)

- **Cache** for recent page‑table entries.
    
- On **TLB hit**, translation is very fast.
    
- On **TLB miss**, the MMU walks the page table (incurs extra memory access), then updates the TLB.
    

---

### 6. Demand Paging

- **Load pages only when needed** (on reference), not at process start.
    
- **Page Fault**: reference to a page not in memory
    
    1. Trap to OS
        
    2. OS finds a free frame or selects a victim (page replacement)
        
    3. If victim dirty → write back to disk
        
    4. Read the needed page into frame
        
    5. Update page table & TLB, restart instruction
        

---

### 7. Page Replacement Algorithms

- **Optimal (Belady’s)**: replace the page not used for longest future time (impractical).
    
- **FIFO**: replace the oldest loaded page.
    
- **LRU (Least Recently Used)**: replace the page not used for longest past time.
    
- **Clock (Second‑Chance)**: circular list with reference bits; gives a “second chance” before replacement.
    
- **Working Set–based**: track pages used in the most recent Δ time units.
    

---

### 8. Thrashing and Working Set Model

- **Thrashing**
    
    - Occurs when the system spends more time handling page faults than executing processes.
        
    - Happens if the **sum of working set sizes** of all processes > physical memory.
        
- **Working Set (WS)**
    
    - The set of pages a process has referenced in its last Δ time units (window).
        
    - OS keeps track of WS size, and only admits processes if their WS can be resident.
        

---

### 9. Memory Allocation Strategies

- **Contiguous Allocation**: each process in one continuous region → suffers external fragmentation.
    
- **Paging** avoids external fragmentation; only internal fragmentation of up to one page per process.
    
- **Segmentation** groups logically related items (code, data, stack) into variable‑length segments.
    
- **Segmented Paging** combines segmentation & paging: segments divided into pages.
    

---

### 10. Implementation Considerations

- **Multi‑level Page Tables**: to avoid huge single‑level tables (e.g., two‑level, inverted).
    
- **Inverted Page Table**: one entry per frame, indexed by frame number → must handle virtual → physical via a hash.
    
- **Protection Bits**: read/write/execute in page table entries.
    
- **Shared Pages**: code pages can be shared between processes; copy‑on‑write for private data.
    

---

### 11. Performance and Tuning

- **Effective Access Time (EAT)**
    
    EAT=(1−p)×memory_access_time+p×page_fault_time \text{EAT} = (1 - p)\times \text{memory\_access\_time} + p\times \text{page\_fault\_time}
    
    where _p_ = page-fault rate.
    
- **Locality Principle**: programs tend to access a small set of pages repeatedly.
    
- **Page Buffering**: keep recently replaced frames in a buffer for quick reinstatement.
    

---

### 12. Command Languages (Brief)

- OS provides a **shell** or CLI to interpret user commands, run programs, and manage I/O redirection.
    
- Commands themselves may be implemented as built‑ins (in the shell) or external executables.
    
- Important for scripting, batch jobs, and interactive resource management.
    

---

### 13. Summary

- Virtual memory decouples logical address space from physical memory, enabling larger, isolated, and efficiently managed programs.
    
- Key mechanisms include paging, TLBs, and page replacement algorithms.
    
- Proper tuning of working sets and allocation strategies prevents thrashing and maximizes throughput.
    
- Understanding these concepts is fundamental to modern operating systems and performance optimization.