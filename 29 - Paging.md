
## Overview

This lecture covers **Chapter 8** of the textbook, focusing on paging as a memory management technique that overcomes the limitations of contiguous memory allocation.

## 1. Introduction to Paging

### Problems with Contiguous Allocation

- **External fragmentation**: Free memory becomes scattered in small, unusable chunks
- **Inflexibility**: Programs must occupy contiguous physical memory space
- **Limitation**: Entire program must fit in available contiguous space

### Paging Solution

- **Non-contiguous allocation**: Program pages can be scattered throughout physical memory
- **Flexibility**: Physical memory allocated to a process doesn't need to be contiguous
- **Efficiency**: Better memory utilization by eliminating external fragmentation

## 2. Basic Paging Concepts

### Key Components

- **Pages**: Fixed-size blocks of logical memory (typically 4KB)
- **Page Frames**: Fixed-size blocks of physical memory (same size as pages)
- **Page Table**: Data structure that maps logical pages to physical frames

### Address Translation

- **Logical Address**: Generated by CPU during program execution
- **Physical Address**: Actual location in physical memory
- **Hardware Translation**: Automatic conversion from logical to physical addresses

## 3. Address Translation Mechanism

### Logical Address Structure

A logical address is divided into two parts:

- **Page Number (p)**: Used as index into page table
- **Page Offset (d)**: Displacement within the page

### Translation Algorithm

1. **Extract Components**: Divide logical address into page number and offset
2. **Page Table Lookup**: Use page number as index to find frame number
3. **Physical Address Formation**: Concatenate frame number with offset
4. **Memory Access**: Retrieve data from calculated physical address

### Example Calculation

- **Page Size**: 4 bytes
- **Logical Address**: 3 bits (addresses 0-7)
- **Physical Address**: 4 bits (addresses 0-15)
- **Page Offset**: 2 bits (log₂(4) = 2)
- **Page Number**: 1 bit (3 - 2 = 1)

## 4. Page Table Implementation

### Location and Management

- **Storage**: Page tables reside in main memory (too large for CPU registers)
- **Per-Process**: Each process has its own page table
- **OS Responsibility**: Operating system sets up and manages page tables
- **Hardware Usage**: Hardware uses page tables for address translation

### Key Registers

- **Page Table Base Register (PTBR)**: Points to current process's page table
- **Page Table Length Register (PTLR)**: Indicates size of page table

### Context Switching

During context switch:

1. Save current PTBR value in process PCB
2. Load new process's page table address into PTBR
3. Hardware automatically uses new page table for translations

## 5. Performance Issues and Solutions

### The Double Memory Access Problem

Every logical memory reference requires:

1. **Page Table Access**: One memory access to get frame number
2. **Data Access**: Another memory access to get actual data
3. **Performance Impact**: Doubles memory access time

### Translation Lookaside Buffer (TLB)

**Solution**: Cache recent page-to-frame translations

#### TLB Structure

- **Hardware Cache**: Fast associative memory in CPU
- **Entries**: Store page number → frame number mappings
- **Process ID**: Some TLBs include address space identifiers

#### TLB Operation

1. **TLB Hit**: Page number found in TLB → Direct frame number retrieval
2. **TLB Miss**: Page number not in TLB → Access page table in memory
3. **TLB Update**: Cache new translation for future use

### Effective Access Time Calculation

With TLB hit ratio α:

- **TLB Access Time**: ε (very small)
- **Memory Access Time**: 1 time unit
- **Effective Access Time**: 2 + ε - α

**Example**: If α = 0.8 (80% hit ratio), effective access time = 1.2 time units

## 6. Memory Protection with Paging

### Valid/Invalid Bits

Each page table entry includes:

- **Valid Bit**: Page is in use by the process
- **Invalid Bit**: Page is not currently used by the process

### Protection Mechanism

- **Illegal Access**: Attempting to access invalid page triggers trap
- **OS Response**: Operating system handles protection violation
- **Error Messages**: Segmentation fault, invalid memory access

### Address Space Utilization

- **Sparse Usage**: Programs rarely use entire logical address space
- **Practical Example**: 32-bit systems have 4GB logical space, but programs use much less
- **Efficiency**: Only allocate physical memory for pages actually in use

## 7. Shared Pages

### Code Sharing Benefits

- **Memory Efficiency**: Multiple processes can share identical code
- **Examples**: Text editors, compilers, system libraries
- **Requirement**: Code must be reentrant (safely executable by multiple processes)

### Implementation

- **Shared Text Pages**: Multiple page tables point to same physical frames
- **Private Data Pages**: Each process has separate data in different frames
- **Page Table Mapping**: Same code pages mapped to same frames across processes

### Example: Three Text Editor Processes

```
Process P1 Page Table:    Process P2 Page Table:    Process P3 Page Table:
Page 0 → Frame 3         Page 0 → Frame 3         Page 0 → Frame 3
Page 1 → Frame 4         Page 1 → Frame 4         Page 1 → Frame 4
Page 2 → Frame 6         Page 2 → Frame 6         Page 2 → Frame 6
Page 3 → Frame 7         Page 3 → Frame 8         Page 3 → Frame 9
(shared code)            (shared code)            (shared code)
(private data)           (private data)           (private data)
```

## 8. Key Advantages of Paging

### Memory Management Benefits

- **No External Fragmentation**: Any free frame can hold any page
- **Efficient Memory Use**: Better utilization of available memory
- **Process Flexibility**: Processes can grow and shrink dynamically

### System Benefits

- **Code Sharing**: Reduces memory requirements for common programs
- **Memory Protection**: Hardware-enforced access control
- **Virtual Memory Support**: Foundation for demand paging and virtual memory

## 9. Important Considerations

### Page Size Trade-offs

- **Smaller Pages**: Less internal fragmentation, larger page tables
- **Larger Pages**: More internal fragmentation, smaller page tables
- **Typical Size**: 4KB is common compromise

### TLB Management

- **Size Limitations**: TLBs are small (64-256 entries typical)
- **Hit Ratio Impact**: Critical for system performance
- **Context Switch Overhead**: May need to flush TLB entries

### Implementation Complexity

- **Hardware Support**: Requires MMU (Memory Management Unit)
- **OS Complexity**: Page table management, frame allocation
- **Performance Tuning**: TLB size, page size selection

## Summary

Paging is a fundamental memory management technique that:

- Eliminates external fragmentation through non-contiguous allocation
- Provides efficient address translation via hardware page tables
- Supports memory protection and code sharing
- Forms the foundation for advanced virtual memory systems
- Requires careful performance optimization through TLB usage

The combination of hardware support and OS management makes paging an essential component of modern operating systems, enabling efficient and flexible memory management for multiple concurrent processes.